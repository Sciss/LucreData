before

1-5---------9
: |         |
: 3----5    7-----9
: |    |    |     |
: 2-3  4-5  6-7   8-9



step-1 -- no way

     1-9
       |
       7-----9
|      |     |
3-4    6-7   8-9


bottom-up

1-5------9
  |      |
  4---5  7-----9
  |      |     |
  3      6-7   8-9

1-5------9
  |      |
  4---5  7-----9
  |      |     |
  3      6-7   8-9


:::::::::::::::::::

1-5---------9
: |         |
: 3----5    7-----9
: |    |    |     |
: 2-3  4-5  6-7   8-9

1-5------9
: |      |
: 5      7-----9
: |      |     |
: 2-3-5  6-7   8-9

1-9
: |
: 5------7-----9
: |      |     |
: 2-3-5  6-7   8-9

:::::::::::::::::::

1-9
: |
: 3----7------9
: |    |      |
: 2-3  5-6-7  8-9

:::::::::::::::::::

with this:

1-5---------9
: |    V    |
: 3----5    7-----9
: |    |    |     |
: 2-3  4-5  6-7   8-9

remove 4. step 1:

pp h				0
p  1-5---------9		1
   : |    V    |
b  : 3----5    7-----9		2
   : |    |    |     |
   : 2-3  4-5  6-7   8-9	3

--> merge right, 5 down ; hence recreate p, and write it into pp
(merge 2, shrink 1, update 0)

   h				0
pp 1-9				1
   : |
p  : 3----5----7-----9		2
   : |    |    |     |
l  : 2-3  4-5  6-7   8-9	3

--> merge 5, delete 4 ; hence recreate p, and write it into pp
(merge 3, shrink 2, update 1)


   h
   1-9
   : |
   : 3----7------9
   : |    |      |
   : 2-3  5-6-7  8-9

that is to say, when the key is not in the upper levels,
we need to cache one level of node-recreation
(in the first step, the 'merge 2' is delayed)

ok, what happens when the search key appears in upper levels?

remove 5:

p  h				0
b  1-5---------9		1
  : |         |
  : 3----5    7-----9		2
  : |    |    |     |
  : 2-3  4-5  6-7   8-9		3

--> remove 5 from 1 ? or ignore for now ?

pp h				0
p  1-5---------9		1
   : |         |
b  : 3----5    7-----9		2
   : |    |    |     |
   : 2-3  4-5  6-7   8-9	3

--> in 2, remove 5 and merge right (delayed!) / in 1 update, in 0 write

   h				0
pp 1-9				1
   : |
p  : 3---(5)...7-----9		2
   : |    |    |     |
l  : 2-3  4-5  6-7   8-9	3

--> in 3, remove 5 and merge right / execute delayed stuff in 2 and write in 1

einfach gesagt, muss es kein delay im sinne der analyse geben; lediglich der down-index muss
bestimmt werden in 'b', aber nicht die size ueberprueft werden. statt dessen wird 'p'
geprueft. // stimmt nicht, die analyse muss schon vollzogen werden in 'b', weil davon
die genau aktion in 'p' abhaengt

::::::::::::: with borrow-right

p  h				0
b  1-5---------11		1
   : |         |
   : 3----5    7-----9----11	2
   : |    |    |     |    |
   : 2-3  4-5  6-7   8-9  10-11	3

--> 5 found. schedule mod (remove '5')
; more like this: remove at idx = found || down-child shrinks

pp h				0
p  1-5---------11		1
   : |         |
b  : 3----5    7-----9----11	2
   : |    |    |     |    |
   : 2-3  4-5  6-7   8-9  10-11	3

--> 5 found. 



:::::::::::::

p  h					0
b  1-5---------11			1
   : |         |
   : 3----5    8-----10-----12		2
   : |    |    |      |     |
   : 2-3  4-5  6-7-8  9-10  11-12	3

remove 5:

p  h					0
b  1-8-------------11			1
   : |             |
   : 3----8        10-----12		2
   : |    |        |      |
   : 2-3  4-6-7-8  9-10  11-12		3


::: the problem is that when removing a key which is spread over several levels, another one gets promoted more than once. hence the only solution without multiple node re-creations is to go bottom-up.
