::::: add a marked vertex :::::

add(entry: (K, A))
   -> mv        = wrap(entry)
      prelist  add mv
      postlist add mv
      skip     add mv

   def wrap:
        iso = query(vertex)
        new M {
          store full vertex

          if iso_preCmp <= 0
            insert this_pre before iso_pre
          else
            insert this_pre after iso_pre
        
          if iso_postCmp <= 0
            insert this_post before iso_post
          else
            insert this_post after iso_post

    def query(v: K): IsoResult
      val (pre, preCmp) = prelist.isomorphicQuery {
        def compare(that: M) = v.pre compare that.fullVertex.pre
      }
      val (post, postCmp) = prelist.isomorphicQuery {
        def compare(that: M) = v.pre compare that.fullVertex.pre
      }


IsoResult {
   pre: Mark
   preCmp: Int
   post: Mark
   postCmp: Int
}

    
a Mark has the following stored information
- fullVertex
- pre
- post
- value

::::::::::::::::::

in scala'ish pseudo code

Vertex = (lb_pre: Label, lb_post: Label)

Field[A]:
  Mark = (v_full: Vertex, v_mark: Vertex, value: A)
  Rel  = (Mark, Cmp)
  Iso  = (rel_pre: Rel, rel_post: Rel)
  Cmp  = -1 | 0 | +1

  val preList : Tree
  val postList: Tree
  val spatial : Spatial

  Spatial:
    def nearest(q: Vertex, direction): A

  Tree:
    def nearest(test: Mark => Cmp): (Mark, Cmp)

  def query(v_full: Vertex): A =
    iso = translate(v)
    if iso.rel_pre.cmp == 0 then iso.rel_pre.mark.value
    else
      start_pre : Label = iso.rel_pre.mark .lb_pre  + iso.rel_pre .cmp
      start_post: Label = iso.rel_post.mark.lb_post + iso.rel_post.cmp
      spatial.nearest((start_pre, start_post), north-west)

  def update(v_full: Vertex, value: A) =

  def compare(a: Label, b: Label): Cmp

  def translate(v_full: Vertex): Iso =
    rel_pre  = preList .nearest(m => compare(v_full.lb_pre  m.v_full.lb_pre ))
    rel_post = postList.nearest(m => compare(v_full.lb_post m.v_full.lb_post))
    (rel_pre, rel_post)
    